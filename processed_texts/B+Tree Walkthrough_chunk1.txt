The insert process starts at the root node. The keys of the root node are searched to ﬁnd out which child node we need to descend to. ○ EX: 10. Since 10 < 42, we follow the pointer to the left of 42 ● Note - none of these new values cause a node to split 5 B+ Tree : m = 4 Insert: 30 ● Starting at root, we descend to the left-most child (we’ll call curr). ○ curr is a leaf node. Thus, we insert 30 into curr. ○ BUT curr is full. So we have to split. ○ Create a new node to the right of curr, temporarily called newNode. ○ Insert newNode into the doubly linked list of leaf nodes. 6 B+ Tree : m = 4 Insert: 30 cont’d. ● re-distribute the keys ● copy the smallest key (27 in this case) from newNode to parent; rearrange keys and pointers in parent node. ● Parent of newNode is also root. So, nothing else to do. 7 B+ Tree : m = 4 Fast forward to this state of the tree… ● Observation: The root node is full. ○ The next insertion that splits a leaf