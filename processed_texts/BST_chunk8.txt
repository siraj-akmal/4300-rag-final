←z 3: else y ←BST-Successor(z) 4:  y is the node that’s actually removed. 5:  Here y does not have two children. 6: if left[y] ̸= nil 7: then x ←left[y] 8: else x ←right[y] 9:  x is the node that’s moving to y’s position. 10: if x ̸= nil then p[x] ←p[y] 11:  p[x] is reset If x isn’t NIL. 12:  Resetting is unnecessary if x is NIL. 19 Algorithm (cont’d) 13: if p[y] = nil then root[T] ←x 14:  If y is the root, then x becomes the root. 15:  Otherwise, do the following. 16: else if y = left[p[y]] 17: then left[p[y]] ←x 18:  If y is the left child of its parent, then 19:  Set the parent’s left child to x. 20: else right[p[y]] ←x 21:  If y is the right child of its parent, then 22:  Set the parent’s right child to x. 23: if y ̸= z then 24: { key[z] ←key[y] 25: Move other data from y to z } 27: return (y) 20 Summary of Eﬃciency Analysis Theorem A On a binary search tree of height h, Search, Minimum, Maximum, Successor, Predecessor,