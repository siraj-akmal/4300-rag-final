points] def closest_pair_sorted(arr): n = len(arr) pair = (0,0) min_diff = float('inf') for x in range(n-1): diff = abs(arr[x] - arr[x+1]) if diff < min_diff: min_diff = diff pair = (arr[x], arr[x+1]) return pair Briefly discuss which algorithm is more efficient in terms of the number of comparisons performed. A formal analysis is not necessary. You can simply state your choice and then justify it. [5 points] The second algorithm is more efficient in terms of the number of comparisons performed, although it is limited to sorted lists. The first algorithm has to check each number against one another, whereas the second one only needs to check each number with the one in front of it. Question 2: Implement in Python an algorithm for a level order traversal of a binary tree. The algorithm should print each level of the binary tree to the screen starting with the lowest/deepest level on the first line. The last line of output should be the root of the tree. Assume your algorithm is passed the root node of an existing binary tree whose structure is based on the following BinTreeNode class. You may use other data structures in the Python foundation library in