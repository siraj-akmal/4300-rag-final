Linked Lists - slow for random access - fast for random insertions 7 Binary Search ● Input: array of values in sorted order, target value ● Output: the location (index) of where target is located or some value indicating target was not found def binary_search(arr, target) left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 8 A C G M P R Z target = A mid Since target < arr[mid], we reset right to mid - 1. left right A C G M P R Z target = A mid left right Time Complexity ●Linear Search ○ Best case: target is found at the ﬁrst element; only 1 comparison ○ Worst case: target is not in the array; n comparisons ○ Therefore, in the worst case, linear search is O(n) time complexity. ●Binary Search ○ Best case: target is found at mid; 1 comparison (inside the loop) ○ Worst case: target is not in the array; log2 n comparisons ○ Therefore, in the worst case, binary search